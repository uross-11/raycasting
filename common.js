export const map = [
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 4, 0, 4, 0, 4, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 4, 0, 4, 0, 4, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 4, 0, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 4, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 5, 0, 4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 4, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
];

export const map2 = [
    [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
    [4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4],
    [4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4],
    [4, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 4],
    [4, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 4],
    [4, 4, 0, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 4],
    [4, 0, 0, 4, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 4],
    [4, 0, 0, 0, 0, 0, 5, 0, 4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 4],
    [4, 0, 0, 4, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 4],
    [4, 0, 0, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 4],
    [4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 4],
    [4, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 4],
    [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
];

export function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
}

export function lerp(a, b, t) {
    return a * (1 - t) + b * t;
}

export function mapKeyCode(code) {
    switch (code) {
        case "ArrowUp":
        case "KeyW":
            return 0;
        case "ArrowDown":
        case "KeyS":
            return 1;
        case "ArrowLeft":
            return 2;
        case "ArrowRight":
            return 3;
        case "KeyA":
            return 6;
        case "KeyD":
            return 7;
        case "KeyF":
            return 8;
        default:
            return 255;
    }
}

export function rotateVectors(dir, plane, angle) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const oldDirX = dir[0];
    const oldPlaneX = plane[0];
    const newDir = [dir[0] * cos - dir[1] * sin, oldDirX * sin + dir[1] * cos];
    const newPlane = [plane[0] * cos - plane[1] * sin, oldPlaneX * sin + plane[1] * cos];
    return { dir: newDir, plane: newPlane };
}

export function tryMovePosition(pos, dx, dy, levelMap) {
    const nx = pos[0] + dx;
    const ny = pos[1] + dy;
    const result = [pos[0], pos[1]];
    if (levelMap[~~pos[1]]?.[~~nx] === 0) result[0] = nx;
    if (levelMap[~~ny]?.[~~result[0]] === 0) result[1] = ny;
    return result;
}

export function isCollidingWithWidth(y, x, playerWidth, levelMap) {
    return (
        levelMap[~~(y - playerWidth)]?.[~~(x - playerWidth)] !== 0 ||
        levelMap[~~(y + playerWidth)]?.[~~(x - playerWidth)] !== 0 ||
        levelMap[~~(y - playerWidth)]?.[~~(x + playerWidth)] !== 0 ||
        levelMap[~~(y + playerWidth)]?.[~~(x + playerWidth)] !== 0
    );
}

export function tryMoveWithWidth(pos, dx, dy, playerWidth, levelMap) {
    let nx = pos[0] + dx;
    let ny = pos[1] + dy;
    let rx = pos[0];
    let ry = pos[1];
    if (!isCollidingWithWidth(pos[1], nx, playerWidth, levelMap)) rx = nx;
    if (!isCollidingWithWidth(ny, rx, playerWidth, levelMap)) ry = ny;
    return [rx, ry];
}

export function displaySwapBackImageData(backCtx, backImageData, ctx) {
    backCtx.putImageData(backImageData, 0, 0);
    ctx.drawImage(backCtx.canvas, 0, 0, ctx.canvas.width, ctx.canvas.height);
}

export function calculateDistance(pos1, pos2) {
    return Math.pow(pos1[0] - pos2[0], 2) + Math.pow(pos1[1] - pos2[1], 2);
}

export function sortSpritesByDistance(sprites, playerPos) {
    sprites.sort((a, b) => {
        const distA = calculateDistance(playerPos, a.pos);
        const distB = calculateDistance(playerPos, b.pos);
        return distB - distA;
    });
}

export const GAME_CONSTANTS = {
    MOVE_SPEED: 3.0,
    ROTATION_SPEED: 3.0,
    PLAYER_WIDTH: 0.2,
    SENSITIVITY: 3,
    FACTOR: 50,
    TILE_SIZE: 10,
    MAP_SHOWN: false,
    MAX_HEALTH: 100,
    DAMAGE_AMOUNT: 10,
};

export const MOVE_SPEED = GAME_CONSTANTS.MOVE_SPEED;
export const ROTATION_SPEED = GAME_CONSTANTS.ROTATION_SPEED;
export const PLAYER_WIDTH = GAME_CONSTANTS.PLAYER_WIDTH;
export const SENSITIVITY = GAME_CONSTANTS.SENSITIVITY;
export const FACTOR = GAME_CONSTANTS.FACTOR;
export const TILE_SIZE = GAME_CONSTANTS.TILE_SIZE;
export const MAP_SHOWN = GAME_CONSTANTS.MAP_SHOWN;
export const MAX_HEALTH = GAME_CONSTANTS.MAX_HEALTH;
export const DAMAGE_AMOUNT = GAME_CONSTANTS.DAMAGE_AMOUNT;

export function intersectRayAABB(rayStartX, rayStartY, rayDirX, rayDirY, boxMinX, boxMinY, boxMaxX, boxMaxY) {
    const tMinX = (boxMinX - rayStartX) / rayDirX;
    const tMaxX = (boxMaxX - rayStartX) / rayDirX;
    const tMinY = (boxMinY - rayStartY) / rayDirY;
    const tMaxY = (boxMaxY - rayStartY) / rayDirY;

    const t1X = Math.min(tMinX, tMaxX);
    const t2X = Math.max(tMinX, tMaxX);
    const t1Y = Math.min(tMinY, tMaxY);
    const t2Y = Math.max(tMinY, tMaxY);

    const tNear = Math.max(t1X, t1Y);
    const tFar = Math.min(t2X, t2Y);

    if (tNear > tFar || tFar < 0) return Infinity;

    return tNear > 0 ? tNear : Infinity;
}

export function performShot(player, allEntities, damageAmount, isServer = false) {
    const rayDirX = player.dir[0];
    const rayDirY = player.dir[1];
    const playerPosX = player.pos[0];
    const playerPosY = player.pos[1];

    let closestHit = Infinity;
    let hitTarget = null;

    for (const targetEntity of allEntities.values()) {
        if (targetEntity.id === player.id) continue;

        let entityX, entityY, entityWidth, entityTag;

        if (targetEntity.type === 'player') {
            entityX = targetEntity.pos[0];
            entityY = targetEntity.pos[1];
            entityWidth = GAME_CONSTANTS.PLAYER_WIDTH;
            entityTag = targetEntity.id;
        } else if (targetEntity.type === 'enemy') {
            entityX = targetEntity.pos[0];
            entityY = targetEntity.pos[1];
            entityWidth = 0.5;
            entityTag = targetEntity.tag;
        } else {
            continue;
        }

        const boxMinX = entityX - entityWidth / 2;
        const boxMinY = entityY - entityWidth / 2;
        const boxMaxX = entityX + entityWidth / 2;
        const boxMaxY = entityY + entityWidth / 2;

        const hitDistance = intersectRayAABB(playerPosX, playerPosY, rayDirX, rayDirY, boxMinX, boxMinY, boxMaxX, boxMaxY);

        if (hitDistance < closestHit) {
            closestHit = hitDistance;
            hitTarget = targetEntity;
        }
    }

    if (hitTarget && closestHit < Infinity) {
        if (isServer) {
            console.log(`Server: ${player.id} hit target:`, hitTarget.id || hitTarget.tag);
            if (hitTarget.health !== undefined) {
                hitTarget.takeDamage(damageAmount);
            }
        }
        return hitTarget; // Return the hit target for client-side use
    } else {
        if (isServer) return null;
    }
}

export function applyInputToPlayer(player, deltaTime, levelMap) {
    const moveStep = MOVE_SPEED * deltaTime;
    const rotStep = ROTATION_SPEED * deltaTime;

    if (player.turningLeft) {
        const r = rotateVectors(player.dir, player.plane, rotStep);
        player.dir = r.dir;
        player.plane = r.plane;
    }
    if (player.turningRight) {
        const r = rotateVectors(player.dir, player.plane, -rotStep);
        player.dir = r.dir;
        player.plane = r.plane;
    }

    if (player.movingForward) {
        player.pos = tryMoveWithWidth(
            player.pos,
            player.dir[0] * moveStep,
            player.dir[1] * moveStep,
            PLAYER_WIDTH,
            levelMap,
        );
    }
    if (player.movingBackward) {
        player.pos = tryMoveWithWidth(
            player.pos,
            -player.dir[0] * moveStep,
            -player.dir[1] * moveStep,
            PLAYER_WIDTH,
            levelMap,
        );
    }
    if (player.movingLeft) {
        player.strafe(-moveStep);
    }
    if (player.movingRight) {
        player.strafe(moveStep);
    }
}

export function encodePlayers(playersArr, spritesArr) {
    const enc = new TextEncoder();
    let size = 1 + 2; // Type (1 byte) + player count (2 bytes)
    const encodedPlayers = playersArr.map((p) => ({ p, idBytes: enc.encode(p.id) }));
    for (const { idBytes } of encodedPlayers) size += 1 + idBytes.length + 4 * 7; // idLen (1) + id (N) + pos (2) + dir (2) + plane (2) + health (1)

    size += 2; // Sprite count (2 bytes)
    const encodedSprites = spritesArr.map((s) => ({ s, tagBytes: enc.encode(s.tag) }));
    for (const { tagBytes } of encodedSprites) size += 1 + tagBytes.length + 4 * 3; // tagLen (1) + tag (N) + pos (2) + health (1)

    const buf = new ArrayBuffer(size);
    const view = new DataView(buf);
    let off = 0;
    view.setUint8(off, 11); // Message type: update
    off += 1;
    view.setUint16(off, playersArr.length, true);
    off += 2;
    for (const { p, idBytes } of encodedPlayers) {
        view.setUint8(off, idBytes.length);
        off += 1;
        new Uint8Array(buf, off, idBytes.length).set(idBytes);
        off += idBytes.length;
        view.setFloat32(off, p.pos[0], true);
        off += 4;
        view.setFloat32(off, p.pos[1], true);
        off += 4;
        view.setFloat32(off, p.dir[0], true);
        off += 4;
        view.setFloat32(off, p.dir[1], true);
        off += 4;
        view.setFloat32(off, p.plane[0], true);
        off += 4;
        view.setFloat32(off, p.plane[1], true);
        off += 4;
        view.setFloat32(off, p.health, true);
        off += 4;
    }

    view.setUint16(off, spritesArr.length, true);
    off += 2;
    for (const { s, tagBytes } of encodedSprites) {
        view.setUint8(off, tagBytes.length);
        off += 1;
        new Uint8Array(buf, off, tagBytes.length).set(tagBytes);
        off += tagBytes.length;
        view.setFloat32(off, s.pos[0], true);
        off += 4;
        view.setFloat32(off, s.pos[1], true);
        off += 4;
        view.setFloat32(off, s.health, true);
        off += 4;
    }
    return buf;
}

export function encodeHello(selfId, playersArr) {
    const enc = new TextEncoder();
    const idBytes = enc.encode(selfId);
    const playersBuf = encodePlayers(playersArr, []); // Initial hello doesn't send sprites
    const total = 1 + 1 + idBytes.length + playersBuf.byteLength;
    const buf = new ArrayBuffer(total);
    const view = new DataView(buf);
    let off = 0;
    view.setUint8(off, 10);
    off += 1;
    view.setUint8(off, idBytes.length);
    off += 1;
    new Uint8Array(buf, off, idBytes.length).set(idBytes);
    off += idBytes.length;
    new Uint8Array(buf, off).set(new Uint8Array(playersBuf));
    return buf;
}

export const MESSAGE_TYPE_IDENTIFY = 0; // New message type for client identification
export const MESSAGE_TYPE_MOVE_INPUT = 1;
export const MESSAGE_TYPE_SHOOT_ACTION = 2;
export const MESSAGE_TYPE_MOUSE_INPUT = 3; // New message type for mouse input

export function encodeIdentify(clientId) {
    const enc = new TextEncoder();
    const idBytes = enc.encode(clientId);
    const buf = new ArrayBuffer(1 + 1 + idBytes.length); // Type (1 byte) + idLen (1 byte) + id (N bytes)
    const view = new DataView(buf);
    let off = 0;
    view.setUint8(off, MESSAGE_TYPE_IDENTIFY);
    off += 1;
    view.setUint8(off, idBytes.length);
    off += 1;
    new Uint8Array(buf, off, idBytes.length).set(idBytes);
    return buf;
}
